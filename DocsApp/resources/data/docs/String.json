{
  "$type": "doxi",
  "files": [
    "../../../../docs/docs/js/primitives/String.js",
    "../../../../docs/docs/js/primitives/Object.js"
  ],
  "global": {
    "$type": "namespace",
    "items": [
      {
        "$type": "class",
        "extended": "Object",
        "extends": "Object",
        "name": "String",
        "text": "\n`{@link String}` is a global object that may be used to construct String instances.\n\nString objects may be created by calling the constructor `new String()`. The `{@link String}` object wraps\nJavaScript's string primitive data type with the methods described below. The global function\n`String()` can also be called without new in front to create a primitive string. String literals in\nJavaScript are primitive strings.\n\nBecause JavaScript automatically converts between string primitives and String objects, you can call\nany of the methods of the `{@link String}` object on a string primitive. JavaScript automatically converts the\nstring primitive to a temporary `{@link String}` object, calls the method, then discards the temporary String\nobject. For example, you can use the `String.length` property on a string primitive created from a\nstring literal:\n\n    s_obj = new String(s_prim = s_also_prim = \"foo\");\n\n    s_obj.length;       // 3\n    s_prim.length;      // 3\n    s_also_prim.length; // 3\n    'foo'.length;       // 3\n    \"foo\".length;       // 3\n\n(A string literal is denoted with single or double quotation marks.)\n\nString objects can be converted to primitive strings with the `{@link #method!valueOf valueOf}` method.\n\nString primitives and String objects give different results when evaluated as JavaScript. Primitives\nare treated as source code; String objects are treated as a character sequence object. For example:\n\n    s1 = \"2 + 2\";               // creates a string primitive\n    s2 = new String(\"2 + 2\");   // creates a String object\n    eval(s1);                   // returns the number 4\n    eval(s2);                   // returns the string \"2 + 2\"\n    eval(s2.valueOf());         // returns the number 4\n\n# Character access\n\nThere are two ways to access an individual character in a string. The first is the `{@link #method!charAt charAt}` method:\n\n    return 'cat'.charAt(1); // returns \"a\"\n\nThe other way is to treat the string as an array, where each index corresponds to an individual\ncharacter:\n\n    return 'cat'[1]; // returns \"a\"\n\nThe second way (treating the string as an array) is not part of ECMAScript 3. It is a JavaScript and\nECMAScript 5 feature.\n\nIn both cases, attempting to set an individual character won't work. Trying to set a character\nthrough `{@link #method!charAt charAt}` results in an error, while trying to set a character via indexing does not throw an\nerror, but the string itself is unchanged.\n\n# Comparing strings\n\nC developers have the `strcmp()` function for comparing strings. In JavaScript, you just use the less-\nthan and greater-than operators:\n\n    var a = \"a\";\n    var b = \"b\";\n    if (a < b) // true\n        print(a + \" is less than \" + b);\n    else if (a > b)\n        print(a + \" is greater than \" + b);\n    else\n        print(a + \" and \" + b + \" are equal.\");\n\nA similar result can be achieved using the `{@link #method!localeCompare localeCompare}` method inherited by `{@link String}` instances.\n\n<div class=\"notice\">\nDocumentation for this class comes from <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String\">MDN</a>\nand is available under <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">Creative Commons: Attribution-Sharealike license</a>.\n</div>\n",
        "items": [
          {
            "$type": "methods",
            "items": [
              {
                "$type": "method",
                "name": "charAt",
                "text": "Returns the character at the specified index.\n\nCharacters in a string are indexed from left to right. The index of the first character is 0, and\nthe index of the last character in a string called `stringName` is `stringName.length - 1`. If the\nindex you supply is out of range, JavaScript returns an empty string.\n\nThe following example displays characters at different locations in the string \"Brave new world\":\n\n    var anyString=\"Brave new world\";\n\n    document.writeln(\"The character at index 0 is '\" + anyString.charAt(0) + \"'\");\n    document.writeln(\"The character at index 1 is '\" + anyString.charAt(1) + \"'\");\n    document.writeln(\"The character at index 2 is '\" + anyString.charAt(2) + \"'\");\n    document.writeln(\"The character at index 3 is '\" + anyString.charAt(3) + \"'\");\n    document.writeln(\"The character at index 4 is '\" + anyString.charAt(4) + \"'\");\n    document.writeln(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\");\n\nThese lines display the following:\n\n    The character at index 0 is 'B'\n    The character at index 1 is 'r'\n    The character at index 2 is 'a'\n    The character at index 3 is 'v'\n    The character at index 4 is 'e'\n    The character at index 999 is ''\n\nThe following provides a means of ensuring that going through a string loop always provides a whole\ncharacter, even if the string contains characters that are not in the Basic Multi-lingual Plane.\n\n    var str = 'A\\uD87E\\uDC04Z'; // We could also use a non-BMP character directly\n    for (var i=0, chr; i < str.length; i++) {\n        if ((chr = getWholeChar(str, i)) === false) {continue;} // Adapt this line at the top of\neach loop, passing in the whole string and the current iteration and returning a variable to\nrepresent the individual character\n        alert(chr);\n    }\n\n    function getWholeChar (str, i) {\n        var code = str.charCodeAt(i);\n\n        if (isNaN(code)) {\n        return ''; // Position not found\n        }\n        if (code < 0xD800 || code > 0xDFFF) {\n            return str.charAt(i);\n        }\n        if (0xD800 <= code && code <= 0xDBFF) { // High surrogate (could change last hex to 0xDB7F\nto treat high private surrogates as single characters)\n        if (str.length <= (i+1))  {\n            throw 'High surrogate without following low surrogate';\n        }\n        var next = str.charCodeAt(i+1);\n        if (0xDC00 > next || next > 0xDFFF) {\n            throw 'High surrogate without following low surrogate';\n        }\n        return str.charAt(i)+str.charAt(i+1);\n    }\n    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n    if (i === 0) {\n        throw 'Low surrogate without preceding high surrogate';\n    }\n    var prev = str.charCodeAt(i-1);\n    if (0xD800 > prev || prev > 0xDBFF) { // (could change last hex to 0xDB7F to treat high private\nsurrogates as single characters)\n      throw 'Low surrogate without preceding high surrogate';\n    }\n    return false; // We can pass over low surrogates now as the second component in a pair which we\nhave already processed\n}\n\nWhile the second example may be more frequently useful for those wishing to support non-BMP\ncharacters (since the above does not require the caller to know where any non-BMP character might\nappear), in the event that one _does_ wish, in choosing a character by index, to treat the surrogate\npairs within a string as the single characters they represent, one can use the following:\n\n    function fixedCharAt (str, idx) {\n        var ret = '';\n        str += '';\n        var end = str.length;\n\n        var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n        while ((surrogatePairs.exec(str)) != null) {\n            var li = surrogatePairs.lastIndex;\n            if (li - 2 < idx) {\n                idx++;\n            }\n            else {\n            break;\n        }\n    }\n\n    if (idx >= end || idx < 0) {\n        return '';\n    }\n\n    ret += str.charAt(idx);\n\n    if (/[\\uD800-\\uDBFF]/.test(ret) && /[\\uDC00-\\uDFFF]/.test(str.charAt(idx+1))) {\n        ret += str.charAt(idx+1); // Go one further, since one of the \"characters\" is part of a\nsurrogate pair\n    }\n    return ret;\n    }\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "index",
                    "text": "An integer between 0 and 1 less than the length of the string.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,259,20",
                      "text": "0,259,26,63",
                      "type": "0,259,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Individual character from string.\n",
                    "type": "String",
                    "src": {
                      "text": "0,260,21,34",
                      "type": "0,260,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,154,12",
                  "text": "0,155,4,4115"
                }
              },
              {
                "$type": "method",
                "name": "charCodeAt",
                "text": "Returns a number indicating the Unicode value of the character at the given index.\n\nUnicode code points range from 0 to 1,114,111. The first 128 Unicode code points are a direct match\nof the ASCII character encoding.\n\nNote that `{@link #method!charCodeAt charCodeAt}` will always return a value that is less than 65,536. This is because the\nhigher code points are represented by a pair of (lower valued) \"surrogate\" pseudo-characters which\nare used to comprise the real character. Because of this, in order to examine or reproduce the full\ncharacter for individual characters of value 65,536 and above, for such characters, it is necessary\nto retrieve not only `charCodeAt(i)`, but also `charCodeAt(i+1)` (as if examining/reproducing a\nstring with two letters). See example 2 and 3 below.\n\n`{@link #method!charCodeAt charCodeAt}` returns `NaN` if the given index is not greater than 0 or is greater than the length of\nthe string.\n\nBackward Compatibility with JavaScript 1.2\n\nThe `{@link #method!charCodeAt charCodeAt}` method returns a number indicating the ISO-Latin-1 codeset value of the character\nat the given index. The ISO-Latin-1 codeset ranges from 0 to 255. The first 0 to 127 are a direct\nmatch of the ASCII character set.\n\nExample 1: Using `{@link #method!charCodeAt charCodeAt}`\n\nThe following example returns 65, the Unicode value for A.\n\n   \"ABC\".charCodeAt(0) // returns 65\n\nExample 2: Fixing `{@link #method!charCodeAt charCodeAt}` to handle non-Basic-Multilingual-Plane characters if their presence\nearlier in the string is unknown\n\nThis version might be used in for loops and the like when it is unknown whether non-BMP characters\nexist before the specified index position.\n\n    function fixedCharCodeAt (str, idx) {\n        // ex. fixedCharCodeAt ('\\uD800\\uDC00', 0); // 65536\n        // ex. fixedCharCodeAt ('\\uD800\\uDC00', 1); // 65536\n        idx = idx || 0;\n        var code = str.charCodeAt(idx);\n        var hi, low;\n        if (0xD800 <= code && code <= 0xDBFF) { // High surrogate (could change last hex to 0xDB7F to treat high private surrogates as single characters)\n            hi = code;\n            low = str.charCodeAt(idx+1);\n            if (isNaN(low)) {\n                throw 'High surrogate not followed by low surrogate in fixedCharCodeAt()';\n            }\n            return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n        }\n        if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate\n        // We return false to allow loops to skip this iteration since should have already handled\nhigh surrogate above in the previous iteration\n            return false;\n        }\n        return code;\n    }\n\nExample 3: Fixing `{@link #method!charCodeAt charCodeAt}` to handle non-Basic-Multilingual-Plane characters if their presence\nearlier in the string is known\n\n    function knownCharCodeAt (str, idx) {\n        str += '';\n        var code,\n        end = str.length;\n\n        var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n        while ((surrogatePairs.exec(str)) != null) {\n            var li = surrogatePairs.lastIndex;\n            if (li - 2 < idx) {\n                idx++;\n            }\n            else {\n                break;\n            }\n        }\n\n        if (idx >= end || idx < 0) {\n            return NaN;\n        }\n\n        code = str.charCodeAt(idx);\n\n        var hi, low;\n        if (0xD800 <= code && code <= 0xDBFF) {\n            hi = code;\n            low = str.charCodeAt(idx+1); // Go one further, since one of the \"characters\" is part of\na surrogate pair\n            return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n        }\n        return code;\n    }\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "index",
                    "text": "An integer greater than 0 and less than the length of the string; if it is\nnot a number, it defaults to 0.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,355,20",
                      "text": "0,355,26,75:0,356,4,32",
                      "type": "0,355,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Value between 0 and 65535.\n",
                    "type": "Number",
                    "src": {
                      "text": "0,357,21,27",
                      "type": "0,357,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,264,12",
                  "text": "0,265,4,3481"
                }
              },
              {
                "$type": "method",
                "name": "concat",
                "text": "Combines combines the text from one or more strings and returns a new string. Changes to the text in\none string do not affect the other string.\n\nThe following example combines strings into a new string.\n\n    var hello = \"Hello, \";\n    console.log(hello.concat(\"Kevin\", \" have a nice day.\")); // Hello, Kevin have a nice day.\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "strings",
                    "text": "The strings to concatenate.\n",
                    "type": "String...",
                    "src": {
                      "name": "0,370,23",
                      "text": "0,370,31,28",
                      "type": "0,370,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Result of both strings.\n",
                    "type": "String",
                    "src": {
                      "text": "0,371,21,24",
                      "type": "0,371,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,361,12",
                  "text": "0,362,4,326"
                }
              },
              {
                "$type": "method",
                "name": "constructor",
                "text": "Creates new String object.\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "value",
                    "text": "The value to wrap into String object.\n",
                    "type": "Object",
                    "src": {
                      "name": "0,81,20",
                      "text": "0,81,26,38",
                      "type": "0,81,12"
                    }
                  }
                ],
                "src": {
                  "name": "0,79,12",
                  "text": "0,80,4,27"
                }
              },
              {
                "$type": "method",
                "name": "fromCharCode",
                "text": "Returns a string created by using the specified sequence of Unicode values.\n\nThis method returns a string and not a `{@link String}` object.\n\nBecause `{@link #method!fromCharCode fromCharCode}` is a static method of `{@link String}`, you always use it as `String.fromCharCode()`,\nrather than as a method of a `{@link String}` object you created.\n\nAlthough most common Unicode values can be represented in a fixed width system/with one number (as\nexpected early on during JavaScript standardization) and `fromCharCode()` can be used to return a\nsingle character for the most common values (i.e., UCS-2 values which are the subset of UTF-16 with\nthe most common characters), in order to deal with ALL legal Unicode values, `fromCharCode()` alone\nis inadequate. Since the higher code point characters use two (lower value) \"surrogate\" numbers to\nform a single character, `fromCharCode()` can be used to return such a pair and thus adequately\nrepresent these higher valued characters.\n\nBe aware, therefore, that the following utility function to grab the accurate character even for\nhigher value code points, may be returning a value which is rendered as a single character, but\nwhich has a string count of two (though usually the count will be one).\n\n    // String.fromCharCode() alone cannot get the character at such a high code point\n    // The following, on the other hand, can return a 4-byte character as well as the\n    //   usual 2-byte ones (i.e., it can return a single character which actually has\n    //   a string length of 2 instead of 1!)\n    alert(fixedFromCharCode(0x2F804)); // or 194564 in decimal\n\n    function fixedFromCharCode (codePt) {\n        if (codePt > 0xFFFF) {\n            codePt -= 0x10000;\n            return String.fromCharCode(0xD800 + (codePt >> 10), 0xDC00 +\n            (codePt & 0x3FF));\n        }\n        else {\n            return String.fromCharCode(codePt);\n        }\n    }\n\nThe following example returns the string \"ABC\".\n\n    String.fromCharCode(65,66,67)\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "numbers",
                    "text": "A sequence of numbers that are Unicode values.\n",
                    "type": "Number...",
                    "src": {
                      "name": "0,128,23",
                      "text": "0,128,31,47",
                      "type": "0,128,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "String containing characters from encoding.\n",
                    "type": "String",
                    "src": {
                      "text": "0,129,21,44",
                      "type": "0,129,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,87,12",
                  "text": "0,88,4,1944"
                }
              },
              {
                "$type": "method",
                "name": "hasOwnProperty",
                "text": "Returns a boolean indicating whether an object contains the specified property as a direct property\nof that object and not inherited through the prototype chain.\n\nEvery object descended from `{@link Object}` inherits the `{@link #method!hasOwnProperty hasOwnProperty}` method. This method can be used\nto determine whether an object has the specified property as a direct property of that object;\nunlike the `in` operator, this method does not check down the object's prototype chain.\n\nThe following example determines whether the o object contains a property named prop:\n\n    o = new Object();\n    o.prop = 'exists';\n\n    function changeO() {\n        o.newprop = o.prop;\n        delete o.prop;\n    }\n\n    o.hasOwnProperty('prop');   //returns true\n    changeO();\n    o.hasOwnProperty('prop');   //returns false\n\nThe following example differentiates between direct properties and properties inherited through the\nprototype chain:\n\n    o = new Object();\n    o.prop = 'exists';\n    o.hasOwnProperty('prop');             // returns true\n    o.hasOwnProperty('toString');         // returns false\n    o.hasOwnProperty('hasOwnProperty');   // returns false\n\nThe following example shows how to iterate over the properties of an object without executing on\ninherit properties.\n\n    var buz = {\n        fog: 'stack'\n    };\n\n    for (var name in buz) {\n        if (buz.hasOwnProperty(name)) {\n            alert(\"this is fog (\" + name + \") for sure. Value: \" + buz[name]);\n        }\n        else {\n            alert(name); // toString or something else\n        }\n    }\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "prop",
                    "text": "The name of the property to test.\n",
                    "type": "String",
                    "src": {
                      "name": "1,100,20",
                      "text": "1,100,25,34",
                      "type": "1,100,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Returns true if object contains specified property; else\nreturns false.\n",
                    "type": "Boolean",
                    "src": {
                      "text": "1,101,22,57:1,102,4,15",
                      "type": "1,101,13"
                    }
                  }
                ],
                "src": {
                  "name": "1,53,12",
                  "text": "1,54,4,1520"
                }
              },
              {
                "$type": "method",
                "name": "indexOf",
                "text": "Returns the index within the calling `{@link String}` object of the first occurrence of the specified value,\nor -1 if not found.\n\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character\nof a string called `stringName` is `stringName.length - 1`.\n\n    \"Blue Whale\".indexOf(\"Blue\")    // returns 0\n    \"Blue Whale\".indexOf(\"Blute\")   // returns -1\n    \"Blue Whale\".indexOf(\"Whale\",0) // returns 5\n    \"Blue Whale\".indexOf(\"Whale\",5) // returns 5\n    \"Blue Whale\".indexOf(\"\",9)      // returns 9\n    \"Blue Whale\".indexOf(\"\",10)     // returns 10\n    \"Blue Whale\".indexOf(\"\",11)     // returns 10\n\nThe `{@link #method!indexOf indexOf}` method is case sensitive. For example, the following expression returns -1:\n\n    \"Blue Whale\".indexOf(\"blue\")\n\nNote that '0' doesn't evaluate to true and '-1' doesn't evaluate to false. Therefore, when checking if a specific string exists\nwithin another string the correct way to check would be:\n\n    \"Blue Whale\".indexOf(\"Blue\") != -1 // true\n    \"Blue Whale\".indexOf(\"Bloe\") != -1 // false\n\nThe following example uses indexOf and lastIndexOf to locate values in the string \"Brave new world\".\n\n    var anyString=\"Brave new world\"\n\n    document.write(\"<P>The index of the first w from the beginning is \" + anyString.indexOf(\"w\"))          // Displays 8\n    document.write(\"<P>The index of the first w from the end is \" + anyString.lastIndexOf(\"w\"))      // Displays 10\n    document.write(\"<P>The index of 'new' from the beginning is \" + anyString.indexOf(\"new\"))        // Displays 6\n    document.write(\"<P>The index of 'new' from the end is \" + anyString.lastIndexOf(\"new\"))    // Displays 6\n\nThe following example defines two string variables. The variables contain the same string except that the second string contains\nuppercase letters. The first `writeln` method displays 19. But because the `{@link #method!indexOf indexOf}` method is case sensitive, the string\n\"cheddar\" is not found in `myCapString`, so the second `writeln` method displays -1.\n\n    myString=\"brie, pepper jack, cheddar\"\n    myCapString=\"Brie, Pepper Jack, Cheddar\"\n    document.writeln('myString.indexOf(\"cheddar\") is ' + myString.indexOf(\"cheddar\"))\n    document.writeln('<P>myCapString.indexOf(\"cheddar\") is ' + myCapString.indexOf(\"cheddar\"))\n\nThe following example sets count to the number of occurrences of the letter x in the string str:\n\n    count = 0;\n    pos = str.indexOf(\"x\");\n    while ( pos != -1 ) {\n        count++;\n        pos = str.indexOf(\"x\",pos+1);\n    }\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "searchValue",
                    "text": "A string representing the value to search for.\n",
                    "type": "String",
                    "src": {
                      "name": "0,427,20",
                      "text": "0,427,32,47",
                      "type": "0,427,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "fromIndex",
                    "text": "The location within the calling string to start the search from. It can be any integer between 0 and\nthe length of the string. The default value is 0.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,428,20",
                      "text": "0,428,30,101:0,429,4,50",
                      "type": "0,428,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Position of specified value or -1 if not found.\n",
                    "type": "Number",
                    "src": {
                      "text": "0,430,21,48",
                      "type": "0,430,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,375,12",
                  "text": "0,376,4,2503"
                }
              },
              {
                "$type": "method",
                "name": "isPrototypeOf",
                "text": "Returns a boolean indication whether the specified object is in the prototype chain of the object\nthis method is called upon.\n\n`{@link #method!isPrototypeOf isPrototypeOf}` allows you to check whether or not an object exists within another object's\nprototype chain.\n\nFor example, consider the following prototype chain:\n\n    function Fee() {\n        // . . .\n    }\n\n    function Fi() {\n        // . . .\n    }\n    Fi.prototype = new Fee();\n\n    function Fo() {\n        // . . .\n    }\n    Fo.prototype = new Fi();\n\n    function Fum() {\n        // . . .\n    }\n    Fum.prototype = new Fo();\n\nLater on down the road, if you instantiate `Fum` and need to check if `Fi`'s prototype exists\nwithin the `Fum` prototype chain, you could do this:\n\n    var fum = new Fum();\n    . . .\n\n    if (Fi.prototype.isPrototypeOf(fum)) {\n    // do something safe\n    }\n\nThis, along with the `instanceof` operator particularly comes in handy if you have code that can\nonly function when dealing with objects descended from a specific prototype chain, e.g., to\nguarantee that certain methods or properties will be present on that object.\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "prototype",
                    "text": "an object to be tested against each link in the prototype chain of the\n*object* argument\n",
                    "type": "Object",
                    "src": {
                      "name": "1,148,20",
                      "text": "1,148,30,71:1,149,4,18",
                      "type": "1,148,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "object",
                    "text": "the object whose prototype chain will be searched\n",
                    "type": "Object",
                    "src": {
                      "name": "1,150,20",
                      "text": "1,150,27,50",
                      "type": "1,150,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Returns true if object is a prototype and false if not.\n",
                    "type": "Boolean",
                    "src": {
                      "text": "1,151,22,56",
                      "type": "1,151,13"
                    }
                  }
                ],
                "src": {
                  "name": "1,106,12",
                  "text": "1,107,4,1084"
                }
              },
              {
                "$type": "method",
                "name": "lastIndexOf",
                "text": "Returns the index within the calling String object of the last occurrence of\nthe specified value, or -1 if not found. The calling string is searched\nbackward, starting at fromIndex.\n\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character\nis `stringName.length - 1`.\n\n    \"canal\".lastIndexOf(\"a\")   // returns 3\n    \"canal\".lastIndexOf(\"a\",2) // returns 1\n    \"canal\".lastIndexOf(\"a\",0) // returns -1\n    \"canal\".lastIndexOf(\"x\")   // returns -1\n\nThe `{@link #method!lastIndexOf lastIndexOf}` method is case sensitive. For example, the following expression returns -1:\n\n    \"Blue Whale, Killer Whale\".lastIndexOf(\"blue\")\n\nThe following example uses `{@link #method!indexOf indexOf}` and `{@link #method!lastIndexOf lastIndexOf}` to locate values in the string \"`Brave new world`\".\n\n    var anyString=\"Brave new world\"\n\n    // Displays 8\n    document.write(\"<P>The index of the first w from the beginning is \" +\n    anyString.indexOf(\"w\"))\n    // Displays 10\n    document.write(\"<P>The index of the first w from the end is \" +\n    anyString.lastIndexOf(\"w\"))\n    // Displays 6\n    document.write(\"<P>The index of 'new' from the beginning is \" +\n    anyString.indexOf(\"new\"))\n    // Displays 6\n    document.write(\"<P>The index of 'new' from the end is \" +\n    anyString.lastIndexOf(\"new\"))\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "searchValue",
                    "text": "A string representing the value to search for.\n",
                    "type": "String",
                    "src": {
                      "name": "0,468,20",
                      "text": "0,468,32,47",
                      "type": "0,468,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "fromIndex",
                    "text": "The location within the calling string to start the search from, indexed from left to right. It can\nbe any integer between 0 and the length of the string. The default value is the length of the string.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,469,20",
                      "text": "0,469,30,100:0,470,4,102",
                      "type": "0,469,12"
                    }
                  },
                  {
                    "$type": "return",
                    "type": "Number",
                    "src": {
                      "type": "0,471,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,434,12",
                  "text": "0,435,4,1283"
                }
              },
              {
                "$type": "method",
                "name": "localeCompare",
                "text": "Returns a number indicating whether a reference string comes before or after or is the same as the\ngiven string in sort order.\n\nReturns a number indicating whether a reference string comes before or after or is the same as the\ngiven string in sort order. Returns -1 if the string occurs earlier in a sort than `compareString`,\nreturns 1 if the string occurs afterwards in such a sort, and returns 0 if they occur at the same\nlevel.\n\nThe following example demonstrates the different potential results for a string occurring before,\nafter, or at the same level as another:\n\n    alert('a'.localeCompare('b')); // -1\n    alert('b'.localeCompare('a')); // 1\n    alert('b'.localeCompare('b')); // 0\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "compareString",
                    "text": "The string against which the referring string is comparing.\n",
                    "type": "String",
                    "src": {
                      "name": "0,491,20",
                      "text": "0,491,34,60",
                      "type": "0,491,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Returns -1 if the string occurs earlier in a sort than\ncompareString, returns 1 if the string occurs afterwards in such a sort, and\nreturns 0 if they occur at the same level.\n",
                    "type": "Number",
                    "src": {
                      "text": "0,492,21,55:0,493,4,120",
                      "type": "0,492,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,475,12",
                  "text": "0,476,4,694"
                }
              },
              {
                "$type": "method",
                "name": "match",
                "text": "Used to match a regular expression against a string.\n\nIf the regular expression does not include the `g` flag, returns the same result as `regexp.exec(string)`.\n\nIf the regular expression includes the `g` flag, the method returns an Array containing all matches. If there were no matches,\nthe method returns `{@link null}`.\n\nThe returned {@link Array} has an extra `input` property, which contains the regexp that generated it as a result. In addition,\nit has an `index` property, which represents the zero-based index of the match in the string.\n\nIn the following example, `{@link #method!match match}` is used to find \"Chapter\" followed by 1 or more numeric characters followed by a decimal point\nand numeric character 0 or more times. The regular expression includes the `i` flag so that case will be ignored.\n\n    str = \"For more information, see Chapter 3.4.5.1\";\n    re = /(chapter \\d+(\\.\\d)*)/i;\n    found = str.match(re);\n    document.write(found);\n\nThis returns the array containing Chapter 3.4.5.1,Chapter 3.4.5.1,.1\n\n\"`Chapter 3.4.5.1`\" is the first match and the first value remembered from `(Chapter \\d+(\\.\\d)*)`.\n\n\"`.1`\" is the second value remembered from `(\\.\\d)`.\n\nThe following example demonstrates the use of the global and ignore case flags with `{@link #method!match match}`. All letters A through E and a\nthrough e are returned, each its own element in the array\n\n    var str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    var regexp = /[A-E]/gi;\n    var matches_array = str.match(regexp);\n    document.write(matches_array);\n\n`matches_array` now equals `['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']`.\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "regexp",
                    "text": "A {@link RegExp} object. If a non-RegExp object `obj` is passed, it is\nimplicitly converted to a RegExp by using `new RegExp(obj)`.\n",
                    "type": "RegExp",
                    "src": {
                      "name": "0,533,20",
                      "text": "0,533,27,71:0,534,4,61",
                      "type": "0,533,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Contains results of the match (if any).\n",
                    "type": "Array",
                    "src": {
                      "text": "0,535,20,40",
                      "type": "0,535,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,498,12",
                  "text": "0,499,4,1593"
                }
              },
              {
                "$type": "method",
                "name": "propertyIsEnumerable",
                "text": "Returns a boolean indicating if the internal ECMAScript DontEnum attribute is set.\n\nEvery object has a `{@link #method!propertyIsEnumerable propertyIsEnumerable}` method. This method can determine whether the specified\nproperty in an object can be enumerated by a `for...in` loop, with the exception of properties\ninherited through the prototype chain. If the object does not have the specified property, this\nmethod returns false.\n\nThe following example shows the use of `{@link #method!propertyIsEnumerable propertyIsEnumerable}` on objects and arrays:\n\n    var o = {};\n    var a = [];\n    o.prop = 'is enumerable';\n    a[0] = 'is enumerable';\n\n    o.propertyIsEnumerable('prop');   // returns true\n    a.propertyIsEnumerable(0);        // returns true\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n    var a = ['is enumerable'];\n\n    a.propertyIsEnumerable(0);          // returns true\n    a.propertyIsEnumerable('length');   // returns false\n\n    Math.propertyIsEnumerable('random');   // returns false\n    this.propertyIsEnumerable('Math');     // returns false\n\nDirect versus inherited properties\n\n    var a = [];\n    a.propertyIsEnumerable('constructor');         // returns false\n\n    function firstConstructor()\n    {\n        this.property = 'is not enumerable';\n    }\n    firstConstructor.prototype.firstMethod = function () {};\n\n    function secondConstructor()\n    {\n        this.method = function method() { return 'is enumerable'; };\n    }\n\n    secondConstructor.prototype = new firstConstructor;\n    secondConstructor.prototype.constructor = secondConstructor;\n\n    var o = new secondConstructor();\n    o.arbitraryProperty = 'is enumerable';\n\n    o.propertyIsEnumerable('arbitraryProperty');   // returns true\n    o.propertyIsEnumerable('method');              // returns true\n    o.propertyIsEnumerable('property');            // returns false\n\n    o.property = 'is enumerable';\n\n    o.propertyIsEnumerable('property');            // returns true\n\n    // These return false as they are on the prototype which\n    // propertyIsEnumerable does not consider (even though the last two\n    // are iteratable with for-in)\n    o.propertyIsEnumerable('prototype'); // returns false (as of JS 1.8.1/FF3.6)\n    o.propertyIsEnumerable('constructor'); // returns false\n    o.propertyIsEnumerable('firstMethod'); // returns false\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "prop",
                    "text": "The name of the property to test.\n",
                    "type": "String",
                    "src": {
                      "name": "1,220,20",
                      "text": "1,220,25,34",
                      "type": "1,220,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "If the object does not have the specified property, this\nmethod returns false.\n",
                    "type": "Boolean",
                    "src": {
                      "text": "1,221,22,57:1,222,4,22",
                      "type": "1,221,13"
                    }
                  }
                ],
                "src": {
                  "name": "1,155,12",
                  "text": "1,156,4,2313"
                }
              },
              {
                "$type": "method",
                "name": "replace",
                "text": "Used to find a match between a regular expression and a string, and to replace the matched substring\nwith a new substring.\n\nThis method does not change the `{@link String}` object it is called on. It simply returns a new string.\n\nTo perform a global search and replace, either include the `g` flag in the regular expression or if\nthe first parameter is a string, include `g` in the flags parameter.\n\nThe replacement string can include the following special replacement patterns:\n\n| Pattern       | Inserts\n|:--------------|:--------------------------------------------------------------------------------------\n| `$$`          | Inserts a `$`.\n| `$&`          | Inserts the matched substring.\n| `$``          | Inserts the portion of the string that precedes the matched substring.\n| `$'`          | Inserts the portion of the string that follows the matched substring.\n| `$n` or `$nn` | Where `n` or `nn` are decimal digits, inserts the _n_th parenthesized submatch string, provided the first\n|               | argument was a `{@link RegExp}` object.\n\nYou can specify a function as the second parameter. In this case, the function will be invoked after the match has been\nperformed. The function's result (return value) will be used as the replacement string. (Note: the above-mentioned special\nreplacement patterns do not apply in this case.) Note that the function will be invoked multiple times for each full match to be\nreplaced if the regular expression in the first parameter is global.\n\nThe arguments to the function are as follows:\n\n| Possible Name | Supplied Value\n|:--------------|:--------------------------------------------------------------------------------------\n| `str`         | The matched substring. (Corresponds to `$&` above.)\n| `p1, p2, ...` | The _n_th parenthesized submatch string, provided the first argument to replace was a `{@link RegExp}` object.\n|               | (Correspond to $1, $2, etc. above.)\n| `offset`      | The offset of the matched substring within the total string being examined. (For example, if the total string\n|               | was \"`abcd`\", and the matched substring was \"`bc`\", then this argument will be 1.)\n| `s`           | The total string being examined.\n\n(The exact number of arguments will depend on whether the first argument was a `{@link RegExp}` object and, if so, how many parenthesized\nsubmatches it specifies.)\n\nThe following example will set `newString` to \"`XXzzzz - XX , zzzz`\":\n\n    function replacer(str, p1, p2, offset, s)\n    {\n        return str + \" - \" + p1 + \" , \" + p2;\n    }\n    var newString = \"XXzzzz\".replace(/(X*)(z*)/, replacer);\n\nIn the following example, the regular expression includes the global and ignore case flags which permits replace to replace each\noccurrence of 'apples' in the string with 'oranges'.\n\n    var re = /apples/gi;\n    var str = \"Apples are round, and apples are juicy.\";\n    var newstr = str.replace(re, \"oranges\");\n    print(newstr);\n\nIn this version, a string is used as the first parameter and the global and ignore case flags are specified in the flags\nparameter.\n\n    var str = \"Apples are round, and apples are juicy.\";\n    var newstr = str.replace(\"apples\", \"oranges\", \"gi\");\n    print(newstr);\n\nBoth of these examples print \"oranges are round, and oranges are juicy.\"\n\nIn the following example, the regular expression is defined in replace and includes the ignore case flag.\n\n    var str = \"Twas the night before Xmas...\";\n    var newstr = str.replace(/xmas/i, \"Christmas\");\n    print(newstr);\n\nThis prints \"Twas the night before Christmas...\"\n\nThe following script switches the words in the string. For the replacement text, the script uses the $1 and $2 replacement\npatterns.\n\n    var re = /(\\w+)\\s(\\w+)/;\n    var str = \"John Smith\";\n    var newstr = str.replace(re, \"$2, $1\");\n    print(newstr);\n\nThis prints \"Smith, John\".\n\nIn this example, all occurrences of capital letters in the string are converted to lower case, and a hyphen is inserted just\nbefore the match location. The important thing here is that additional operations are needed on the matched item before it is\ngiven back as a replacement.\n\nThe replacement function accepts the matched snippet as its parameter, and uses it to transform the case and concatenate the\nhyphen before returning.\n\n    function styleHyphenFormat(propertyName)\n    {\n        function upperToHyphenLower(match)\n        {\n            return '-' + match.toLowerCase();\n        }\n        return propertyName.replace(/[A-Z]/, upperToHyphenLower);\n    }\n\nGiven `styleHyphenFormat('borderTop')`, this returns 'border-top'.\n\nBecause we want to further transform the _result_ of the match before the final substitution is made, we must use a function.\nThis forces the evaluation of the match prior to the `toLowerCase()` method. If we had tried to do this using the match without a\n function, the `toLowerCase()` would have no effect.\n\n    var newString = propertyName.replace(/[A-Z]/, '-' + '$&'.toLowerCase());  // won't work\n\nThis is because `'$&'.toLowerCase()` would be evaluated first as a string literal (resulting in the same `'$&'`) before using the\ncharacters as a pattern.\n\nThe following example replaces a Fahrenheit degree with its equivalent Celsius degree. The Fahrenheit degree should be a number\nending with F. The function returns the Celsius number ending with C. For example, if the input number is 212F, the function\n returns 100C. If the number is 0F, the function returns -17.77777777777778C.\n\nThe regular expression `test` checks for any number that ends with F. The number of Fahrenheit degree is accessible to the\nfunction through its second parameter, `p1`. The function sets the Celsius number based on the Fahrenheit degree passed in a\nstring to the `f2c` function. `f2c` then returns the Celsius number. This function approximates Perl's `s///e` flag.\n\n    function f2c(x)\n    {\n        function convert(str, p1, offset, s)\n        {\n            return ((p1-32) * 5/9) + \"C\";\n        }\n        var s = String(x);\n        var test = /(\\d+(?:\\.\\d*)?)F\\b/g;\n        return s.replace(test, convert);\n    }\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "pattern",
                    "text": "Either a string or regular expression pattern to search for.\n",
                    "type": "String/RegExp",
                    "src": {
                      "name": "0,667,27",
                      "text": "0,667,35,61",
                      "type": "0,667,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "replacement",
                    "text": "Either string or function:\n\n- The String to replace the `pattern` with. Number of special replacement patterns are supported;\n  see the \"Specifying a string as a parameter\" section above.\n- A function to be invoked to create the replacement.\n  The arguments supplied to this function are described in the \"Specifying a function as a parameter\"\n  section above.\n",
                    "type": "String/Function",
                    "src": {
                      "name": "0,669,29",
                      "text": "0,669,41,27:0,670,4,335",
                      "type": "0,669,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "String of matched replaced items.\n",
                    "type": "String",
                    "src": {
                      "text": "0,677,21,34",
                      "type": "0,677,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,539,12",
                  "text": "0,540,4,6053"
                }
              },
              {
                "$type": "method",
                "name": "search",
                "text": "Executes the search for a match between a regular expression and a specified string.\n\nIf successful, search returns the index of the regular expression inside the string. Otherwise, it\nreturns -1.\n\nWhen you want to know whether a pattern is found in a string use search (similar to the regular\nexpression `test` method); for more information (but slower execution) use `{@link #method!match match}` (similar to the\nregular expression `exec` method).\n\nThe following example prints a message which depends on the success of the test.\n\n    function testinput(re, str){\n        if (str.search(re) != -1)\n            midstring = \" contains \";\n        else\n            midstring = \" does not contain \";\n        document.write (str + midstring + re);\n    }\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "regexp",
                    "text": "A regular expression object. If a non-RegExp object obj is passed, it is\nimplicitly converted to a RegExp by using `new RegExp(obj)`.\n",
                    "type": "RegExp",
                    "src": {
                      "name": "0,701,20",
                      "text": "0,701,27,73:0,702,4,61",
                      "type": "0,701,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "If successful, search returns the index of the regular\nexpression inside the string. Otherwise, it returns -1.\n",
                    "type": "Number",
                    "src": {
                      "text": "0,703,21,55:0,704,4,56",
                      "type": "0,703,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,681,12",
                  "text": "0,682,4,729"
                }
              },
              {
                "$type": "method",
                "name": "slice",
                "text": "Extracts a section of a string and returns a new string.\n\n`{@link #method!slice slice}` extracts the text from one string and returns a new string. Changes to the text in one\nstring do not affect the other string.\n\n`{@link #method!slice slice}` extracts up to but not including `endSlice`. `string.slice(1,4)` extracts the second\ncharacter through the fourth character (characters indexed 1, 2, and 3).\n\nAs a negative index, `endSlice` indicates an offset from the end of the string. `string.slice(2,-1)`\nextracts the third character through the second to last character in the string.\n\nThe following example uses slice to create a new string.\n\n    // assumes a print function is defined\n    var str1 = \"The morning is upon us.\";\n    var str2 = str1.slice(4, -2);\n    print(str2);\n\nThis writes:\n\n    morning is upon u\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "beginSlice",
                    "text": "The zero-based index at which to begin extraction.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,731,20",
                      "text": "0,731,31,51",
                      "type": "0,731,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "endSlice",
                    "text": "The zero-based index at which to end extraction. If omitted, `{@link #method!slice slice}`\nextracts to the end of the string.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,732,20",
                      "text": "0,732,29,69:0,733,4,35",
                      "type": "0,732,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "All characters from specified start up to (but excluding)\nend.\n",
                    "type": "String",
                    "src": {
                      "text": "0,734,21,58:0,735,4,5",
                      "type": "0,734,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,708,12",
                  "text": "0,709,4,775"
                }
              },
              {
                "$type": "method",
                "name": "split",
                "text": "Splits a `{@link String}` object into an array of strings by separating the string into substrings.\n\nThe `{@link #method!split split}` method returns the new array.\n\nWhen found, `separator` is removed from the string and the substrings are returned in an array. If\n`separator` is omitted, the array contains one element consisting of the entire string.\n\nIf `separator` is a regular expression that contains capturing parentheses, then each time separator\nis matched the results (including any undefined results) of the capturing parentheses are spliced\ninto the output array. However, not all browsers support this capability.\n\nNote: When the string is empty, `{@link #method!split split}` returns an array containing one empty string, rather than an\nempty array.\n\nThe following example defines a function that splits a string into an array of strings using the\nspecified separator. After splitting the string, the function displays messages indicating the\noriginal string (before the split), the separator used, the number of elements in the array, and the\nindividual array elements.\n\n    function splitString(stringToSplit,separator)\n    {\n        var arrayOfStrings = stringToSplit.split(separator);\n        print('The original string is: \"' + stringToSplit + '\"');\n        print('The separator is: \"' + separator + '\"');\n        print(\"The array has \" + arrayOfStrings.length + \" elements: \");\n\n        for (var i=0; i < arrayOfStrings.length; i++)\n            print(arrayOfStrings[i] + \" / \");\n    }\n\n    var tempestString = \"Oh brave new world that has such people in it.\";\n    var monthString = \"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\";\n\n    var space = \" \";\n    var comma = \",\";\n\n    splitString(tempestString, space);\n    splitString(tempestString);\n    splitString(monthString, comma);\n\nThis example produces the following output:\n\n    The original string is: \"Oh brave new world that has such people in it.\"\n    The separator is: \" \"\n    The array has 10 elements: Oh / brave / new / world / that / has / such / people / in / it. /\n\n    The original string is: \"Oh brave new world that has such people in it.\"\n    The separator is: \"undefined\"\n    The array has 1 elements: Oh brave new world that has such people in it. /\n\nThe original string is: \"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\"\nThe separator is: \",\"\nThe array has 12 elements: Jan / Feb / Mar / Apr / May / Jun / Jul / Aug / Sep / Oct / Nov / Dec /\n\nIn the following example, `{@link #method!split split}` looks for 0 or more spaces followed by a semicolon followed by 0\nor more spaces and, when found, removes the spaces from the string. nameList is the array returned\nas a result of split.\n\n    var names = \"Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand \";\n    print(names);\n    var re = /\\s*;\\s*\\/;\n    var nameList = names.split(re);\n    print(nameList);\n\nThis prints two lines; the first line prints the original string, and the second line prints the\nresulting array.\n\n    Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand\n    Harry Trump,Fred Barney,Helen Rigby,Bill Abel,Chris Hand\n\nIn the following example, split looks for 0 or more spaces in a string and returns the first 3\nsplits that it finds.\n\n    var myString = \"Hello World. How are you doing?\";\n    var splits = myString.split(\" \", 3);\n    print(splits);\n\nThis script displays the following:\n\n    Hello,World.,How\n\nIf `separator` contains capturing parentheses, matched results are returned in the array.\n\n    var myString = \"Hello 1 word. Sentence number 2.\";\n    var splits = myString.split(/(\\d)/);\n    print(splits);\n\nThis script displays the following:\n\n    Hello ,1, word. Sentence number ,2, .\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "seperator",
                    "text": "Specifies the character to use for separating the string. The separator is treated as a string or a\nregular expression. If separator is omitted, the array returned contains one element consisting of the entire string.\n",
                    "type": "String",
                    "src": {
                      "name": "0,831,20",
                      "text": "0,831,30,100:0,832,4,118",
                      "type": "0,831,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "limit",
                    "text": "Integer specifying a limit on the number of splits to be found.  The split method still splits on every\nmatch of separator, but it truncates the returned array to at most limit elements.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,833,20",
                      "text": "0,833,26,104:0,834,4,83",
                      "type": "0,833,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Substrings are returned in an array.\n",
                    "type": "Array",
                    "src": {
                      "text": "0,835,20,37",
                      "type": "0,835,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,739,12",
                  "text": "0,740,4,3614"
                }
              },
              {
                "$type": "method",
                "name": "substr",
                "text": "Returns the characters in a string beginning at the specified location through the specified number\nof characters.\n\n`start` is a character index. The index of the first character is 0, and the index of the last\ncharacter is 1 less than the length of the string. `{@link #method!substr substr}` begins extracting characters at start\nand collects length characters (unless it reaches the end of the string first, in which case it will\nreturn fewer).\n\nIf `start` is positive and is greater than or equal to the length of the string, `{@link #method!substr substr}` returns an\nempty string.\n\nIf `start` is negative, `{@link #method!substr substr}` uses it as a character index from the end of the string. If start\nis negative and abs(start) is larger than the length of the string, `{@link #method!substr substr}` uses 0 as the start\nindex. Note: the described handling of negative values of the start argument is not supported by\nMicrosoft JScript.\n\nIf length is 0 or negative, `{@link #method!substr substr}` returns an empty string. If length is omitted, `{@link #method!substr substr}`\nextracts characters to the end of the string.\n\nConsider the following script:\n\n    // assumes a print function is defined\n    var str = \"abcdefghij\";\n    print(\"(1,2): \"    + str.substr(1,2));\n    print(\"(-3,2): \"   + str.substr(-3,2));\n    print(\"(-3): \"     + str.substr(-3));\n    print(\"(1): \"      + str.substr(1));\n    print(\"(-20, 2): \" + str.substr(-20,2));\n    print(\"(20, 2): \"  + str.substr(20,2));\n\nThis script displays:\n\n    (1,2): bc\n    (-3,2): hi\n    (-3): hij\n    (1): bcdefghij\n    (-20, 2): ab\n    (20, 2):\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "start",
                    "text": "Location at which to begin extracting characters.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,879,20",
                      "text": "0,879,26,50",
                      "type": "0,879,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "length",
                    "text": "The number of characters to extract.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,880,20",
                      "text": "0,880,27,37",
                      "type": "0,880,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Modified string.\n",
                    "type": "String",
                    "src": {
                      "text": "0,881,21,17",
                      "type": "0,881,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,839,12",
                  "text": "0,840,4,1474"
                }
              },
              {
                "$type": "method",
                "name": "substring",
                "text": "Returns the characters in a string between two indexes into the string.\n\nsubstring extracts characters from indexA up to but not including indexB. In particular:\n*   If `indexA` equals `indexB`, `{@link #method!substring substring}` returns an empty string.\n*   If `indexB` is omitted, substring extracts characters to the end of the string.\n*   If either argument is less than 0 or is `NaN`, it is treated as if it were 0.\n*   If either argument is greater than `stringName.length`, it is treated as if it were\n`stringName.length`.\n\nIf `indexA` is larger than `indexB`, then the effect of substring is as if the two arguments were\nswapped; for example, `str.substring(1, 0) == str.substring(0, 1)`.\n\nThe following example uses substring to display characters from the string \"Sencha\":\n\n    // assumes a print function is defined\n    var anyString = \"Sencha\";\n\n    // Displays \"Sen\"\n    print(anyString.substring(0,3));\n    print(anyString.substring(3,0));\n\n    // Displays \"cha\"\n    print(anyString.substring(3,6));\n    print(anyString.substring(6,3));\n\n    // Displays \"Sencha\"\n    print(anyString.substring(0,6));\n    print(anyString.substring(0,10));\n\nThe following example replaces a substring within a string. It will replace both individual\ncharacters and `substrings`. The function call at the end of the example changes the string \"Brave\nNew World\" into \"Brave New Web\".\n\n    function replaceString(oldS, newS, fullS) {\n        // Replaces oldS with newS in the string fullS\n        for (var i = 0; i < fullS.length; i++) {\n            if (fullS.substring(i, i + oldS.length) == oldS) {\n                fullS = fullS.substring(0, i) + newS + fullS.substring(i + oldS.length,\nfullS.length);\n            }\n        }\n        return fullS;\n    }\n\n    replaceString(\"World\", \"Web\", \"Brave New World\");\n",
                "items": [
                  {
                    "$type": "param",
                    "name": "indexA",
                    "text": "An integer between 0 and one less than the length of the string.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,932,20",
                      "text": "0,932,27,65",
                      "type": "0,932,12"
                    }
                  },
                  {
                    "$type": "param",
                    "name": "indexB",
                    "text": "(optional) An integer between 0 and the length of the string.\n",
                    "type": "Number",
                    "src": {
                      "name": "0,933,20",
                      "text": "0,933,27,62",
                      "type": "0,933,12"
                    }
                  },
                  {
                    "$type": "return",
                    "text": "Returns the characters in a string between two indexes into the string.\n",
                    "type": "String",
                    "src": {
                      "text": "0,934,21,72",
                      "type": "0,934,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,885,12",
                  "text": "0,886,4,1781"
                }
              },
              {
                "$type": "method",
                "name": "toLocaleLowerCase",
                "text": "The characters within a string are converted to lower case while respecting the current locale. For\nmost languages, this will return the same as `{@link #method!toLowerCase toLowerCase}`.\n\nThe `{@link #method!toLocaleLowerCase toLocaleLowerCase}` method returns the value of the string converted to lower case according to\nany locale-specific case mappings. `{@link #method!toLocaleLowerCase toLocaleLowerCase}` does not affect the value of the string\nitself. In most cases, this will produce the same result as `toLowerCase()`, but for some locales,\nsuch as Turkish, whose case mappings do not follow the default case mappings in Unicode, there may\nbe a different result.\n\nThe following example displays the string \"sencha\":\n\n    var upperText=\"SENCHA\";\n    document.write(upperText.toLocaleLowerCase());\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "Returns value of the string in lowercase.\n",
                    "type": "String",
                    "src": {
                      "text": "0,953,21,42",
                      "type": "0,953,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,938,12",
                  "text": "0,939,4,711"
                }
              },
              {
                "$type": "method",
                "name": "toLocaleString",
                "text": "Returns a string representing the object. This method is meant to be overridden by derived objects\nfor locale-specific purposes.\n\n`{@link Object}`'s `{@link #method!toLocaleString toLocaleString}` returns the result of calling `{@link #method!toString toString}`.\n\nThis function is provided to give objects a generic `{@link #method!toLocaleString toLocaleString}` method, even though not all\nmay use it. Currently, only `{@link Array}`, `{@link Number}`, and `{@link Date}` override `{@link #method!toLocaleString toLocaleString}`.\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "Object represented as a string.\n",
                    "type": "String",
                    "src": {
                      "text": "1,235,21,32",
                      "type": "1,235,13"
                    }
                  }
                ],
                "src": {
                  "name": "1,226,12",
                  "text": "1,227,4,384"
                }
              },
              {
                "$type": "method",
                "name": "toLocaleUpperCase",
                "text": "The characters within a string are converted to upper case while respecting the current locale. For\nmost languages, this will return the same as `{@link #method!toUpperCase toUpperCase}`.\n\nThe `{@link #method!toLocaleUpperCase toLocaleUpperCase}` method returns the value of the string converted to upper case according to\nany locale-specific case mappings. `{@link #method!toLocaleUpperCase toLocaleUpperCase}` does not affect the value of the string\nitself. In most cases, this will produce the same result as `toUpperCase()`, but for some locales,\nsuch as Turkish, whose case mappings do not follow the default case mappings in Unicode, there may\nbe a different result.\n\nThe following example displays the string \"SENCHA\":\n\n    var lowerText=\"sencha\";\n    document.write(lowerText.toLocaleUpperCase());\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "Returns value of the string in uppercase.\n",
                    "type": "String",
                    "src": {
                      "text": "0,972,21,42",
                      "type": "0,972,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,957,12",
                  "text": "0,958,4,711"
                }
              },
              {
                "$type": "method",
                "name": "toLowerCase",
                "text": "Returns the calling string value converted to lower case.\n\nThe `{@link #method!toLowerCase toLowerCase}` method returns the value of the string converted to lowercase. `{@link #method!toLowerCase toLowerCase}` does\nnot affect the value of the string itself.\n\nThe following example displays the lowercase string \"sencha\":\n\n    var upperText=\"SENCHA\";\n    document.write(upperText.toLowerCase());\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "Returns value of the string in lowercase.\n",
                    "type": "String",
                    "src": {
                      "text": "0,987,21,42",
                      "type": "0,987,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,976,12",
                  "text": "0,977,4,340"
                }
              },
              {
                "$type": "method",
                "name": "toString",
                "text": "Returns a string representing the specified object. Overrides the `Object.toString` method.\n\nThe `{@link String}` object overrides the `{@link #method!toString toString}` method of the `{@link Object}` object; it does not inherit\n`Object.toString`. For `{@link String}` objects, the `{@link #method!toString toString}` method returns a string representation of\nthe object.\n\nThe following example displays the string value of a String object:\n\n    x = new String(\"Hello world\");\n    alert(x.toString())      // Displays \"Hello world\"\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "A string representation of the object.\n",
                    "type": "String",
                    "src": {
                      "text": "0,1003,21,39",
                      "type": "0,1003,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,991,12",
                  "text": "0,992,4,460"
                }
              },
              {
                "$type": "method",
                "name": "toUpperCase",
                "text": "Returns the calling string value converted to uppercase.\n\nThe `{@link #method!toUpperCase toUpperCase}` method returns the value of the string converted to uppercase. `{@link #method!toUpperCase toUpperCase}` does\nnot affect the value of the string itself.\n\nThe following example displays the string \"SENCHA\":\n    var lowerText=\"sencha\";\n    document.write(lowerText.toUpperCase());\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "Returns value of the string in uppercase.\n",
                    "type": "String",
                    "src": {
                      "text": "0,1018,21,42",
                      "type": "0,1018,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,1007,12",
                  "text": "0,1008,4,254:0,1015,4,74"
                }
              },
              {
                "$type": "method",
                "name": "trim",
                "text": "Removes whitespace from both ends of the string.\n\nDoes not affect the value of the string itself.\n\nThe following example displays the lowercase string `\"foo\"`:\n\n    var orig = \"   foo  \";\n    alert(orig.trim());\n\n**NOTE:** This method is part of the ECMAScript 5 standard.\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "A string stripped of whitespace on both ends.\n",
                    "type": "String",
                    "src": {
                      "text": "0,1051,21,46",
                      "type": "0,1051,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,1039,12",
                  "text": "0,1040,4,274"
                }
              },
              {
                "$type": "method",
                "name": "valueOf",
                "text": "Returns the primitive value of the specified object. Overrides the `Object.valueOf` method.\n\nThe `{@link #method!valueOf valueOf}` method of String returns the primitive value of a `{@link String}` object as a string data\ntype. This value is equivalent to `String.toString`.\n\nThis method is usually called internally by JavaScript and not explicitly in code.\n\n    x = new String(\"Hello world\");\n    alert(x.valueOf())          // Displays \"Hello world\"\n",
                "items": [
                  {
                    "$type": "return",
                    "text": "Returns value of string.\n",
                    "type": "String",
                    "src": {
                      "text": "0,1033,21,25",
                      "type": "0,1033,13"
                    }
                  }
                ],
                "src": {
                  "name": "0,1022,12",
                  "text": "0,1023,4,422"
                }
              }
            ]
          },
          {
            "$type": "properties",
            "items": [
              {
                "$type": "property",
                "name": "constructor",
                "text": " Specifies the function that creates an object's prototype.\n\n Returns a reference to the Object function that created the instance's prototype. Note that the\n value of this property is a reference to the function itself, not a string containing the\n function's name, but it isn't read only (except for primitive Boolean, Number or String values: 1,\n true, \"read-only\").\n\n All objects inherit a `constructor` property from their `{@link #property!prototype prototype}`:\n\n     o = new Object // or o = {} in JavaScript 1.2\n     o.constructor == Object\n     a = new Array // or a = [] in JavaScript 1.2\n     a.constructor == Array\n     n = new Number(3)\n     n.constructor == Number\n\n Even though you cannot construct most HTML objects, you can do comparisons. For example,\n\n     document.constructor == Document\n     document.form3.constructor == Form\n\n The following example creates a prototype, `Tree`, and an object of that type, theTree. The example then displays the `constructor` property for the object `theTree`.\n\n     function Tree(name) {\n         this.name = name;\n     }\n     theTree = new Tree(\"Redwood\");\n     console.log(\"theTree.constructor is \" + theTree.constructor);\n\n This example displays the following output:\n\n     theTree.constructor is function Tree(name) {\n         this.name = name;\n     }\n\n The following example shows how to modify constructor value of generic objects. Only true, 1 and\n \"test\" variable constructors will not be changed. This example explains that is not always so safe\n to believe in constructor function.\n\n     function Type(){};\n     var\ttypes = [\n \t    new Array,\t[],\n\t    new Boolean,\ttrue,\n\t    new Date,\n\t    new Error,\n\t    new Function,\tfunction(){},\n\t    Math,\n\t    new Number,\t1,\n\t    new Object,\t{},\n\t    new RegExp,\t/(?:)/,\n\t    new String,\t\"test\"\n     ];\n     for(var i = 0; i < types.length; i++){\n         types[i].constructor = Type;\n         types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];\n     };\n     alert(types.join(\"\\n\"));\n",
                "src": {
                  "name": "1,346,14",
                  "text": "1,347,3,1996"
                }
              },
              {
                "$type": "property",
                "name": "length",
                "text": "Reflects the length of the string.\n\nThis property returns the number of code units in the string. UTF-16, the string format used by JavaScript, uses a single 16-bit\ncode unit to represent the most common characters, but needs to use two code units for less commonly-used characters, so it's\npossible for the value returned by `{@link #property!length length}` to not match the actual number of characters in the string.\n\nFor an empty string, `{@link #property!length length}` is 0.\n\n    var x = \"Netscape\";\n    var empty = \"\";\n\n    console.log(\"Netspace is \" + x.length + \" code units long\");\n    console.log(\"The empty string is has a length of \" + empty.length); // should be 0\n",
                "type": "Number",
                "src": {
                  "name": "0,135,23",
                  "text": "0,136,4,630",
                  "type": "0,135,15"
                }
              },
              {
                "$type": "property",
                "name": "prototype",
                "text": "Allows the addition of properties to all objects of type Object.\n",
                "src": {
                  "name": "1,46,14",
                  "text": "1,47,4,65"
                }
              }
            ]
          }
        ],
        "src": {
          "name": "0,2,11",
          "text": "0,3,4,3126"
        }
      }
    ]
  },
  "version": 1
}