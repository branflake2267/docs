{
  "$type": "doxi",
  "files": [
    "../../../ext/packages/core/src/class/Mixin.js"
  ],
  "global": {
    "$type": "namespace",
    "items": [
      {
        "$type": "class",
        "access": "protected",
        "name": "Ext.Mixin",
        "text": "This class is a base class for mixins. These are classes that extend this class and are\ndesigned to be used as a `mixin` by user code.\n\nIt provides mixins with the ability to \"hook\" class methods of the classes in to which\nthey are mixed. For example, consider the `destroy` method pattern. If a mixin class\nhad cleanup requirements, it would need to be called as part of `destroy`.\n\nStarting with a basic class we might have:\n\n     Ext.define('Foo.bar.Base', {\n         destroy: function () {\n             console.log('B');\n             // cleanup\n         }\n     });\n\nA derived class would look like this:\n\n     Ext.define('Foo.bar.Derived', {\n         extend: 'Foo.bar.Base',\n\n         destroy: function () {\n             console.log('D');\n             // more cleanup\n\n             this.callParent(); // let Foo.bar.Base cleanup as well\n         }\n     });\n\nTo see how using this class help, start with a \"normal\" mixin class that also needs to\ncleanup its resources. These mixins must be called explicitly by the classes that use\nthem. For example:\n\n     Ext.define('Foo.bar.Util', {\n         destroy: function () {\n             console.log('U');\n         }\n     });\n\n     Ext.define('Foo.bar.Derived', {\n         extend: 'Foo.bar.Base',\n\n         mixins: {\n             util: 'Foo.bar.Util'\n         },\n\n         destroy: function () {\n             console.log('D');\n             // more cleanup\n\n             this.mixins.util.destroy.call(this);\n\n             this.callParent(); // let Foo.bar.Base cleanup as well\n         }\n     });\n\n     var obj = new Foo.bar.Derived();\n\n     obj.destroy();\n     // logs D then U then B\n\nThis class is designed to solve the above in simpler and more reliable way.\n\n## mixinConfig\n\nUsing `mixinConfig` the mixin class can provide \"before\" or \"after\" hooks that do not\ninvolve the derived class implementation. This also means the derived class cannot\nadjust parameters to the hook methods.\n\n     Ext.define('Foo.bar.Util', {\n         extend: 'Ext.Mixin',\n\n         mixinConfig: {\n             after: {\n                 destroy: 'destroyUtil'\n             }\n         },\n\n         destroyUtil: function () {\n             console.log('U');\n         }\n     });\n\n     Ext.define('Foo.bar.Class', {\n         mixins: {\n             util: 'Foo.bar.Util'\n         },\n\n         destroy: function () {\n             console.log('D');\n         }\n     });\n\n     var obj = new Foo.bar.Derived();\n\n     obj.destroy();\n     // logs D then U\n\n If the destruction should occur in the other order, you can use `before`:\n\n     Ext.define('Foo.bar.Util', {\n         extend: 'Ext.Mixin',\n\n         mixinConfig: {\n             before: {\n                 destroy: 'destroyUtil'\n             }\n         },\n\n         destroyUtil: function () {\n             console.log('U');\n         }\n     });\n\n     Ext.define('Foo.bar.Class', {\n         mixins: {\n             util: 'Foo.bar.Util'\n         },\n\n         destroy: function () {\n             console.log('D');\n         }\n     });\n\n     var obj = new Foo.bar.Derived();\n\n     obj.destroy();\n     // logs U then D\n\n### Chaining\n\nOne way for a mixin to provide methods that act more like normal inherited methods is\nto use an `on` declaration. These methods will be injected into the `callParent` chain\nbetween the derived and superclass. For example:\n\n     Ext.define('Foo.bar.Util', {\n         extend: 'Ext.Mixin',\n\n         mixinConfig: {\n             on: {\n                 destroy: function () {\n                     console.log('M');\n                 }\n             }\n         }\n     });\n\n     Ext.define('Foo.bar.Base', {\n         destroy: function () {\n             console.log('B');\n         }\n     });\n\n     Ext.define('Foo.bar.Derived', {\n         extend: 'Foo.bar.Base',\n\n         mixins: {\n             util: 'Foo.bar.Util'\n         },\n\n         destroy: function () {\n             this.callParent();\n             console.log('D');\n         }\n     });\n\n     var obj = new Foo.bar.Derived();\n\n     obj.destroy();\n     // logs M then B then D\n\nAs with `before` and `after`, the value of `on` can be a method name.\n\n     Ext.define('Foo.bar.Util', {\n         extend: 'Ext.Mixin',\n\n         mixinConfig: {\n             on: {\n                 destroy: 'onDestroy'\n             }\n         }\n\n         onDestroy: function () {\n             console.log('M');\n         }\n     });\n\nBecause this technique leverages `callParent`, the derived class controls the time and\nparameters for the call to all of its bases (be they `extend` or `mixin` flavor).\n\n### Derivations\n\nSome mixins need to process class extensions of their target class. To do this you can\ndefine an `extended` method like so:\n\n     Ext.define('Foo.bar.Util', {\n         extend: 'Ext.Mixin',\n\n         mixinConfig: {\n             extended: function (baseClass, derivedClass, classBody) {\n                 // This function is called whenever a new \"derivedClass\" is created\n                 // that extends a \"baseClass\" in to which this mixin was mixed.\n             }\n         }\n     });\n",
        "src": {
          "access": "0,208,4",
          "name": "0,210,0",
          "text": "0,2,4,5022"
        }
      }
    ]
  },
  "version": 1
}