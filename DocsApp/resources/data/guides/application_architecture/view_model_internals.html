<html>
<head>
    <title>View Model Internals</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/app.css">
</head>
<body>
<div class="contents"><h1 id="application_architecture-_-view_model_internals_-_viewmodel_internals">ViewModel Internals</h1>
<p>Now that you&#39;ve seen <a href="./view_models_data_binding.html">what a ViewModel can do</a>, let&#39;s 
dig in a bit on what is happening under the covers. Having a basic understanding of the
mechanics will help you diagnose issues because you will know what the ViewModel does 
with your declarations.</p>
<p>The ViewModel has two distinct jobs: managing changes to the data object and scheduling 
the bindings when data changes.</p>
<h2 id="application_architecture-_-view_model_internals_-_viewmodel_data_and_inheritance">ViewModel Data and Inheritance</h2>
<p>The ViewModel class manages a &quot;data&quot; object and it leverages the JavaScript prototype
chain to provide value inheritance. Said in picture form:</p>
<p><img src="images/view_model_internals.jpeg"/></p>
<p>This means that all components can read properties set by the top-level container 
(stored in its data object, &quot;Data 1&quot;). Say we have this in Container 1:</p>
<pre><code>viewModel: {
    data: {
        foo: 42
    }
}
</code></pre><p>This allows all components to bind to <code>{foo}</code>. This is typically used to track important
records (like &quot;currentUser&quot; perhaps) that are needed at many levels of the application. 
In fact, because of the use of the JavaScript prototype chain to represent the data,
publishing an object in the ViewModel is often a good idea if changes to properties are 
to be shared as well. To see why, consider a two-way binding to <code>{foo}</code> but in a child 
of Container 2:</p>
<pre><code>{
    xtype: &#39;textfield&#39;,
    bind: &#39;{foo}&#39;
}
</code></pre><p>The text field will receive &quot;42&quot; via Data 2&#39;s prototype chain ultimately from Data 1.
Changes made by this component, however, are stored on Data 2. This is because these
components are bound to their ViewModel and its data object which means the two-way 
nature of the bind will effectively call <code>set</code> on ViewModel 2 which, acting as a normal
JavaScript object, calls sets <code>foo</code> on Data 2. This &quot;forking&quot; can be a useful way to
initialize values that are then separate by view.</p>
<p>To share &quot;live&quot; properties via inheritance, an object should be stored in the root
ViewModel instead:</p>
<pre><code>viewModel: {
    data: {
        stuff: {
            foo: 42
        }
    }
}
</code></pre><p>Now the two-way binding will update the &quot;foo&quot; property on the shared &quot;stuff&quot; object:</p>
<pre><code>{
    xtype: &#39;textfield&#39;,
    bind: &#39;{stuff.foo}&#39;
}
</code></pre><h2 id="application_architecture-_-view_model_internals_-_scheduling_and_dependencies">Scheduling and Dependencies</h2>
<p>The key to making data binding fast is to avoid redundant or unnecessary calculation.<br>To manage this, the ViewModel tracks the dependencies between data. Every binding and 
formula introduces a dependency. Under the hood, a ViewModel breaks these down one 
indirection at a time and creates a linear schedule. This schedule is processed on a 
delay when data is changed.</p>
<p>So if you set a value in the ViewModel or change a field of a record, you don&#39;t need to
worry that a flood of recalculations will immediately take place. Likewise, if a formula
depends on 7 values and you need to change all of them, the formula will only be
recalculated once. To take it further, if you have 7 formulas, each using the other (so 
a chain 7 deep), and each depends on 7 other values, changes to all of the 49 values 
will cause each formula to be recalculated just once.</p>
<p>To achieve this, these dependencies have to be known to the ViewModel and they have to 
be acyclical. A cycle in the dependency graph is reported as an error. This is easy to 
see in this contrived example:</p>
<pre><code>Ext.define(&#39;App.view.broken.BrokenModel&#39;, {
    extend: &#39;Ext.app.ViewModel&#39;,

    formulas: {
        bar: function (get) {
            return get(&#39;foo&#39;) / 2;
        },
        foo: function (get) {
            return get(&#39;bar&#39;) * 2;
        }
    }
});
</code></pre><p>In real applications these bugs will likely not be so obvious, but clearly &quot;foo&quot; and 
&quot;bar&quot; depend on each other so there can be no sequence of evaluation for these two 
methods that yields a proper answer.</p>
<h2 id="application_architecture-_-view_model_internals_-_formula_dependencies">Formula Dependencies</h2>
<p>When a formula uses an explicit bind then its dependencies are obvious. When a formula
just provides a function or a <code>get</code> method, then the ViewModel <strong>parses the text of the
function</strong> looking for property references. While this is extremely convenient and 
ensures that you don&#39;t forget to list a dependency in an explicit bind, there are 
limitations to this approach. For details on formula parsing, see 
[[ext:Ext.app.bind.Formula]].</p>
</div>

    <div class="toc">
        <div class="toc-item"><a href="#application_architecture-_-view_model_internals_-_viewmodel_data_and_inheritance">ViewModel Data and Inheritance</a></div>
        <div class="toc-item"><a href="#application_architecture-_-view_model_internals_-_scheduling_and_dependencies">Scheduling and Dependencies</a></div>
        <div class="toc-item"><a href="#application_architecture-_-view_model_internals_-_formula_dependencies">Formula Dependencies</a></div>
    </div>
</body>
</html>
