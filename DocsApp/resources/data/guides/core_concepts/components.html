<html>
<head>
    <title>Components</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/app.css">
</head>
<body>
<div class="contents"><h1 id="core_concepts-_-components_-_components">Components</h1>
<p>An Ext JS application&#39;s UI is made up of one or many widgets called [[ext:Ext.Component
Component]]s. All Components are subclasses of the [[ext:Ext.Component]] class
which allows them to participate in automated lifecycle management including
instantiation, rendering, sizing and positioning, and destruction.
Ext JS provides a wide range of useful Components out of the box, and any Component can
easily be extended to create a customized Component.</p>
<h2 id="core_concepts-_-components_-_the_component_hierarchy">The Component Hierarchy</h2>
<p>A [[ext:Ext.container.Container Container]] is a special type of Component that can
contain other Components. A typical application is made up of many nested Components in a
tree-like
structure that is referred to as the Component hierarchy.  Containers are responsible for
managing the Component lifecycle of their children, which includes creation, rendering,
sizing and positioning, and destruction. A typical application&#39;s Component hierarchy
starts with a [[ext:Ext.container.Viewport Viewport]] at the top,
which has other Containers and/or Components nested within it:</p>
<p><img src='images/component_heirarchy_5.png' alt='Component Hierarchy'/></p>
<p>Child Components are added to a Container using the Container&#39;s
[[ext:Ext.container.Container#cfg-items items]] configuration property.  This example uses
[[ext:Ext#create Ext.create()]]
to instantiate two [[ext:Ext.panel.Panel Panel]]s, then adds those Panels as child
Components of a Viewport:</p>
<pre><code>@example
var childPanel1 = Ext.create(&#39;Ext.panel.Panel&#39;, {
    title: &#39;Child Panel 1&#39;,
    html: &#39;A Panel&#39;
});

var childPanel2 = Ext.create(&#39;Ext.panel.Panel&#39;, {
    title: &#39;Child Panel 2&#39;,
    html: &#39;Another Panel&#39;
});

Ext.create(&#39;Ext.container.Viewport&#39;, {
    items: [ childPanel1, childPanel2 ]
});
</code></pre><p>Containers use [[ext:Ext.layout.container.Container Layout Manager]]s to size and position
their child Components.
For more information on Layouts and Containers please refer to the <a href="./layouts.html">Layouts and Containers
Guide</a>.</p>
<h2 id="core_concepts-_-components_-_xtypes_and_lazy_instantiation">XTypes and Lazy Instantiation</h2>
<p>Every Component has a symbolic name called an [[ext:Ext.Component#cfg-xtype xtype]]. For
example [[ext:Ext.panel.Panel]] has an <code>xtype</code> of &#39;panel&#39;.
The above example showed how to add already instantiated [[ext:Ext.Component Component]]s
to a [[ext:Ext.container.Container Container]].
In a large application, however, this is not ideal since not all of the Components need to
be instantiated right away,
and some Components might never be instantiated depending on how the application is used.
For example an application that uses a [[ext:Ext.tab.Panel Tab Panel]]
will only need the contents of each tab to be rendered if and when each tab is clicked on
by the user. This is where <code>xtype</code>s come in handy
by allowing a Container&#39;s children to be configured up front, but not instantiated until
the Container determines it is necessary.</p>
<p>The following example code demonstrates lazy instantiation and rendering of a Container&#39;s
Child components using a Tab Panel.
Each tab has an event listener that displays an alert when the tab is rendered.</p>
<pre><code>    @example
    Ext.create(&#39;Ext.tab.Panel&#39;, {
        renderTo: Ext.getBody(),
        height: 100,
        width: 200,
        items: [
            {
                // Explicitly define the xtype of this Component configuration.
                // This tells the Container (the tab panel in this case)
                // to instantiate a Ext.panel.Panel when it deems necessary
                xtype: &#39;panel&#39;,
                title: &#39;Tab One&#39;,
                html: &#39;The first tab&#39;,
                listeners: {
                    render: function() {
                        Ext.MessageBox.alert(&#39;Rendered One&#39;, &#39;Tab One was rendered.&#39;);
                    }
                }
            },
            {
                // xtype for all Component configurations in a Container
                title: &#39;Tab Two&#39;,
                html: &#39;The second tab&#39;,
                listeners: {
                    render: function() {
                        Ext.MessageBox.alert(&#39;Rendered One&#39;, &#39;Tab Two was rendered.&#39;);
                    }
                }
            }
        ]
    });
</code></pre><p>Running this code results in an immediate alert for the first tab. This happens because it
is the default active tab,
and so its Container Tab Panel instantiates and renders it immediately.</p>
<p><img src='images/lazy_render1.png' alt='Lazy Render 1'/></p>
<p>The alert for the second tab does not get displayed until the tab is clicked on. This
shows that the tab was not rendered until
needed, since the [[ext:Ext.Component#event-render render]] event did not fire until the
tab was activated.</p>
<p><img src='images/lazy_render2.png' alt='Lazy Render 2'/></p>
<h2 id="core_concepts-_-components_-_showing_and_hiding">Showing and Hiding</h2>
<p>All [[ext:Ext.Component Component]]s have built in [[ext:Ext.Component#method-show show]]
and [[ext:Ext.Component#method-hide hide]] methods.
The default CSS method used to hide the Component is &quot;display: none&quot;, but this can be
changed using the [[ext:Ext.Component#cfg-hideMode hideMode]] configuration:</p>
<pre><code>    var panel = Ext.create(&#39;Ext.panel.Panel&#39;, {
        renderTo: Ext.getBody(),
        title: &#39;Test&#39;,
        html: &#39;Test Panel&#39;,
        hideMode: &#39;visibility&#39; // use the CSS visibility property to show and hide this
component
    });

    panel.hide(); // hide the component

    panel.show(); // show the component
</code></pre><h2 id="core_concepts-_-components_-_floating_components">Floating Components</h2>
<p>Floating [[ext:Ext.Component Component]] are positioned outside of the document flow using
CSS absolute positioning, and do not participate in their Containers&#39; layout.
Some Components such as [[ext:Ext.window.Window Window]]s are floating by default, but any
Component can be made floating using the [[ext:Ext.Component#cfg-floating floating]]
configuration.</p>
<pre><code>var panel = Ext.create(&#39;Ext.panel.Panel&#39;, {
    width: 200,
    height: 100,
    floating: true, // make this panel an absolutely-positioned floating component
    title: &#39;Test&#39;,
    html: &#39;Test Panel&#39;
});
</code></pre><p>The above code instantiates a [[ext:Ext.panel.Panel Panel]] but does not render it.
Normally a Component either has a [[ext:Ext.Component#cfg-renderTo renderTo]]
configuration specified, or is added as a child Component of a
[[ext:Ext.container.Container Container]], but in the case of floating Components neither
of these is needed.
Floating Components are automatically rendered to the document body the first time their
[[ext:Ext.Component#method-show show]] method is called:</p>
<pre><code>panel.show(); // render and show the floating panel
</code></pre><p>Here are a few other configurations and methods to make note of related to floating
components:</p>
<ul>
<li>[[ext:Ext.Component#cfg-draggable draggable]] - enables dragging of a floating Component
around the screen.</li>
<li>[[ext:Ext.Component#cfg-shadow shadow]] - customizes the look of a floating Component&#39;s
shadow.</li>
<li>[[ext:Ext.Component#method-alignTo alignTo()]] - aligns a floating Component to a
specific element.</li>
<li>[[ext:Ext.Component#method-center center()]] - centers a floating Component in its
Container.</li>
</ul>
<h2 id="core_concepts-_-components_-_creating_custom_components">Creating Custom Components</h2>
<h3 id="core_concepts-_-components_-_composition_or_extension">Composition or Extension</h3>
<p>When creating a new UI class, the decision must be made whether that class should own an
instance of a [[ext:Ext.Component Component]], or to extend that Component.</p>
<p>It is recommended to extend the nearest base class to the functionality required. This is
because of the automated lifecycle management Ext JS provides which
includes automated rendering when needed, automatic sizing and positioning of Components
when managed by an appropriate layout manager,
and automated destruction on removal from a [[ext:Ext.container.Container Container]].</p>
<p>It is easier to write a new class which is a Component and can take its place in the
Component hierarchy rather than a new class which has an Ext JS Component,
and then has to render and manage it from outside.</p>
<h3 id="core_concepts-_-components_-_subclassing">Subclassing</h3>
<p>The [[ext:Ext.Class Class System]] makes it easy to extend any part of the Ext JS framework.</p>
<p>[[ext:Ext.Base Ext.Base]] is the building block of all Ext JS classes, and the prototype and static members
of this class are inherited by all other classes.</p>
<p>While you can certainly begin adding functionality at the lowest possible level via Ext.Base, in many
cases developers want to start a bit higher in the inheritance chain.</p>
<p>The following example creates a subclass of [[ext:Ext.Component]]:</p>
<pre><code>Ext.define(&#39;My.custom.Component&#39;, {
    extend: &#39;Ext.Component&#39;,

    newMethod : function() {
       //...
    }
});
</code></pre><p>This example creates a new class, My.custom.Component, which inherits all of the functionality (methods, properties, etc.)
of Ext.Component in addition to any new methods or properties defined.</p>
<h3 id="core_concepts-_-components_-_template_methods">Template Methods</h3>
<p>Ext JS uses the <a href="http://en.wikipedia.org/wiki/Template_method_design_pattern">Template method
pattern</a> to delegate to
subclasses, behavior which is specific only to that subclass.</p>
<p>This means each class in the inheritance chain may &quot;contribute&quot; an extra
piece of logic to certain phases in the Component&#39;s lifecycle.
Each class implements its own special behavior while allowing the other classes in the
inheritance chain to continue to contribute their own logic.</p>
<p>An example is the render function. <code>render</code> is a method defined in
[[ext:Ext.Component Component]].  It is responsible for initiating the
rendering phase of the Component lifecycle.
<code>render</code> must not be overridden, but it calls <code>onRender</code> during processing to allow the
subclass implementor to add an <code>onRender</code>
method to perform class-specific processing. Every <code>onRender</code> method must call its
superclass&#39; <code>onRender</code> method before &quot;contributing&quot; its extra logic.</p>
<p>The diagram below illustrates the functioning of the <code>onRender</code> template method.</p>
<p>The <code>render</code> method is called (This is done by a Container&#39;s layout manager). This method
may not be overridden and is implemented by the Ext base class.
It calls <code>this.onRender</code> which is the implementation within the current subclass (if
implemented).
This calls the superclass version which calls its superclass version etc. Eventually, each
class has contributed its functionality, and control returns to the <code>render</code> function.</p>
<p><img src='images/template_pattern.png' alt='Template Pattern'/></p>
<p>Here is an example of a Component subclass that implements the <code>onRender</code> method:</p>
<pre><code>Ext.define(&#39;My.custom.Component&#39;, {
    extend: &#39;Ext.Component&#39;,
    onRender: function() {
        this.callParent(arguments); // call the superclass onRender method

        // perform additional rendering tasks here.
    }
});
</code></pre><p>It is important to note that many of the template methods also have a corresponding event.
For example the [[ext:Ext.Component#event-render render]]
event is fired after the Component is rendered.  When subclassing, however, it is it is
essential to use template methods to perform class logic at
important phases in the lifecycle and <em>not</em> events. Events may be programmatically
suspended, or may be stopped by a handler.</p>
<p>Below are the template methods that can be implemented by subclasses of Component:</p>
<ul>
<li><code>initComponent</code>
This method is invoked by the constructor. It is used to initialize data, set up
configurations, and attach event handlers.</li>
<li><code>beforeShow</code>
This method is invoked before the Component is shown.</li>
<li><code>onShow</code>
Allows addition of behavior to the show operation. After calling the superclass&#39;s onShow,
the Component will be visible.</li>
<li><code>afterShow</code>
This method is invoked after the Component is shown.</li>
<li><code>onShowComplete</code>
This method is invoked after the <code>afterShow</code> method is complete</li>
<li><code>onHide</code>
Allows addition of behavior to the hide operation. After calling the superclass&#39;s onHide,
the Component will be hidden.</li>
<li><code>afterHide</code>
This method is invoked after the Component has been hidden</li>
<li><code>onRender</code>
Allows addition of behavior to the rendering phase.</li>
<li><code>afterRender</code>
Allows addition of behavior after rendering is complete. At this stage the Component&#39;s
Element will have been styled according to the configuration,
will have had any configured CSS class names added, and will be in the configured
visibility and the configured enable state.</li>
<li><code>onEnable</code>
Allows addition of behavior to the enable operation. After calling the superclass&#39;s
onEnable, the Component will be enabled.</li>
<li><code>onDisable</code>
Allows addition of behavior to the disable operation. After calling the superclass&#39;s
onDisable, the Component will be disabled.</li>
<li><code>onAdded</code>
Allows addition of behavior when a Component is added to a Container. At this stage, the
Component is in the parent Container&#39;s collection of child items.
After calling the superclass&#39;s onAdded, the ownerCt reference will be present, and if
configured with a ref, the refOwner will be set.</li>
<li><code>onRemoved</code>
Allows addition of behavior when a Component is removed from its parent Container. At this
stage, the Component has been removed from its parent Container&#39;s
collection of child items, but has not been destroyed (It will be destroyed if the parent
Container&#39;s autoDestroy is true, or if the remove call was passed a truthy second
parameter).
After calling the superclass&#39;s onRemoved, the ownerCt and the refOwner will not be
present.</li>
<li><code>onResize</code>
Allows addition of behavior to the resize operation.</li>
<li><code>onPosition</code>
Allows addition of behavior to the position operation.</li>
<li><code>onDestroy</code>
Allows addition of behavior to the destroy operation. After calling the superclass&#39;s
onDestroy, the Component will be destroyed.</li>
<li><code>beforeDestroy</code>
This method is invoked before the Component is destroyed.</li>
<li><code>afterSetPosition</code>
This method is invoked after the Components position has been set.</li>
<li><code>afterComponentLayout</code>
This method is invoked after the Component is laid out.</li>
<li><code>beforeComponentLayout</code>
This method is invoked before the Component is laid out.</li>
</ul>
<h3 id="core_concepts-_-components_-_which_class_to_extend">Which Class To Extend</h3>
<p>Choosing the best class to extend is mainly a matter of efficiency, and which capabilities
the base class must provide.
There has been a tendency to always extend [[ext:Ext.panel.Panel]] whenever any set of UI
Components needs to be rendered and managed.</p>
<p>The Panel class has many capabilities:</p>
<ul>
<li>Border</li>
<li>Header</li>
<li>Header tools</li>
<li>Footer</li>
<li>Footer buttons</li>
<li>Top toolbar</li>
<li>Bottom toolbar</li>
<li>Containing and managing child Components</li>
</ul>
<p>If these are not needed, then using a Panel is a waste of resources.</p>
<h4 id="core_concepts-_-components_-_component">Component</h4>
<p>If the required UI Component does not need to contain any other Components, that is, if it
just to encapsulate some form of HTML which performs the requirements,
then extending [[ext:Ext.Component]] is appropriate. For example, the following class is a
Component that wraps an HTML image element, and allows setting
and getting of the image&#39;s <code>src</code> attribute. It also fires a <code>load</code> event when the image is
loaded:</p>
<pre><code>Ext.define(&#39;Ext.ux.Image&#39;, {
    extend: &#39;Ext.Component&#39;, // subclass Ext.Component
    alias: &#39;widget.managedimage&#39;, // this component will have an xtype of &#39;managedimage&#39;

    autoEl: {
        tag: &#39;img&#39;,
        src: Ext.BLANK_IMAGE_URL,
        cls: &#39;my-managed-image&#39;
    },

    // Add custom processing to the onRender phase.
    // Add a &#39;load&#39; listener to the element.
    onRender: function() {
        this.autoEl = Ext.apply({}, this.initialConfig, this.autoEl);
        this.callParent(arguments);
        this.el.on(&#39;load&#39;, this.onLoad, this);
    },

    onLoad: function() {
        this.fireEvent(&#39;load&#39;, this);
    },

    setSrc: function(src) {
        if (this.rendered) {
            this.el.dom.src = src;
        } else {
            this.src = src;
        }
    },

    getSrc: function(src) {
        return this.el.dom.src || this.src;
    }
});
</code></pre><p>Usage:</p>
<pre><code>var image = Ext.create(&#39;Ext.ux.Image&#39;);

Ext.create(&#39;Ext.panel.Panel&#39;, {
    title: &#39;Image Panel&#39;,
    height: 200,
    renderTo: Ext.getBody(),
    items: [ image ]
});

image.on(&#39;load&#39;, function() {
    console.log(&#39;image loaded: &#39;, image.getSrc());
});

image.setSrc(&#39;http://www.sencha.com/img/sencha-large.png&#39;);
</code></pre><p><em>This example is for demonstration purposes only -
the [[ext:Ext.Img]] class should be used for managing images in a real world application.</em></p>
<h4 id="core_concepts-_-components_-_container">Container</h4>
<p>If the required UI Component is to contain other Components, but does not need any of the
previously mentioned additional capabilities of a [[ext:Ext.panel.Panel Panel]],
then [[ext:Ext.container.Container]] is the appropriate class to extend. At the Container
level, it is important to remember which [[ext:Ext.layout.container.Container]]
is to be used to render and manage child Components.</p>
<p>Containers have the following additional template methods:</p>
<ul>
<li><code>onBeforeAdd</code>
This method is invoked before adding a new child Component. It is passed the new
Component, and may be used to modify the Component, or prepare the Container in some way.
Returning false aborts the add operation.</li>
<li><code>onAdd</code>
This method is invoked after a new Component has been added. It is passed the Component
which has been added. This method may be used to update any internal structure which may
depend upon the state of the child items.</li>
<li><code>onRemove</code>
This method is invoked after a new Component has been removed. It is passed the Component
which has been removed. This method may be used to update any internal structure which may
depend upon the state of the child items.</li>
<li><code>beforeLayout</code>
This method is invoked before the Container has laid out (and rendered if necessary) its
child Components.</li>
<li><code>afterLayout</code>
This method is invoked after the Container has laid out (and rendered if necessary) its
child Components.</li>
</ul>
<h4 id="core_concepts-_-components_-_panel">Panel</h4>
<p>If the required UI Component must have a header, footer, or toolbars, then Ext.panel.Panel is
the appropriate class to extend.</p>
<p><em>Important</em>: A Panel is a Container. It is important to remember which
[[ext:Ext.layout.container.Container Layout]] is to be used to render and manage child
Components.</p>
<p>Classes which extend Ext.panel.Panel are usually highly application-specific and are generally
used to aggregate other UI Components
(Usually Containers, or form Fields) in a configured layout, and provide means to operate
on the contained Components by means
of controls in the [[ext:Ext.panel.Panel#cfg-tbar tbar]] and the
[[ext:Ext.panel.Panel#cfg-bbar bbar]].</p>
<p>Panels have the following additional template methods:</p>
<ul>
<li><code>afterCollapse</code>
This method is invoked after the Panel is Collapsed.</li>
<li><code>afterExpand</code>
This method is invoked after the Panel is expanded</li>
<li><code>onDockedAdd</code>
This method is invoked after a docked item is added to the Panel</li>
<li><code>onDockedRemove</code>
This method is invoked after a docked item is removed from the Panel</li>
</ul>
</div>

    <div class="toc">
        <div class="toc-item"><a href="#core_concepts-_-components_-_the_component_hierarchy">The Component Hierarchy</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_xtypes_and_lazy_instantiation">XTypes and Lazy Instantiation</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_showing_and_hiding">Showing and Hiding</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_floating_components">Floating Components</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_creating_custom_components">Creating Custom Components</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_composition_or_extension">Composition or Extension</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_subclassing">Subclassing</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_template_methods">Template Methods</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_which_class_to_extend">Which Class To Extend</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_component">Component</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_container">Container</a></div>
        <div class="toc-item"><a href="#core_concepts-_-components_-_panel">Panel</a></div>
    </div>
</body>
</html>
